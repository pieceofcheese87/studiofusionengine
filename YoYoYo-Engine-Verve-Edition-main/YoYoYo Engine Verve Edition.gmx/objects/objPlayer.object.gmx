<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frozen = false; //Sets if the player can move or not

jumpSpeed = 8.5 * sign(global.grav); //Set how fast the player jumps
djumpSpeed = 7 * sign(global.grav); //Sets how fast the player double jumps
gravity = 0.4 * sign(global.grav); //Player gravity

djump = 1; //Allow the player to double jump as soon as he spawns
runSpeed = 3;   //Max horizontal speed
maxVspeed = 9;  //Max vertical speed
image_speed = 0.2;
onPlatform = false;

xScale = 1;

scrSetPlayerMask();

if (global.difficulty == 0 &amp;&amp; global.gameStarted)
    { instance_create(x,y,objBow); }
    
if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}

xsafe = x;
ysafe = y;

scrDynamicCollision(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy the bow
with (objBow)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Resolve collisions between step and now, collide with dynamic blocks

if (!place_free(x, y))
{
    var dirX = sign(x-xsafe);
    var dirY = sign(y-ysafe);
    var epsilon = 0.001; //Appease the floating point gods
    
    //If something moved the player into a block since Step, move back towards where we were until we're out of a block.
    while(!place_free(x, y))
    {
        if (dirX * (x - xsafe) &gt;= epsilon)
        {
            x -= sign(x-xsafe) * min( abs(x-xsafe), 1 );
        }
        else if (dirY * (y - ysafe) &gt;= epsilon)
        {
            y -= sign(y-ysafe) * min( abs(y-ysafe), 1 );
        }
        else break;
    }
}

if (global.blocksCrush)
{
    scrDynamicCollision(false, scrKillPlayer);
}
else
{
    scrDynamicCollision(false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision

var killer = instance_place(x, y, objPlayerKiller)
if (killer != noone)
{
    scrKillPlayer();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Screen border death, player animation

if ((bbox_right &lt; 0 || bbox_left &gt; room_width || bbox_bottom &lt; 0 || bbox_top &gt; room_height) &amp;&amp; global.edgeDeath)
{
    scrKillPlayer();
}


var notOnBlock = (p_place_free(0, sign(global.grav)));
var onVineR = (p_place_meeting(1, 0, objVineR) &amp;&amp; notOnBlock);
var onVineL = (p_place_meeting(-1, 0, objVineL) &amp;&amp; notOnBlock);

if (!onVineR &amp;&amp; !onVineL)   //Not touching any vines
{
    if (onPlatform || !notOnBlock)  //Standing on something
    {
        //Check if moving left/right
        var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
        var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
        
        if ((L || R) &amp;&amp; !frozen)
        {
            sprite_index = sprPlayerRun;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprPlayerIdle;
            image_speed = 1/5;
        }
    }
    else    //In the air
    { 
        if ((vspeed * global.grav) &lt; 0)
        {
            sprite_index = sprPlayerJump;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprPlayerFall;
            image_speed = 1/2;
        }
    }
}
else    //Touching a vine
{
    sprite_index = sprPlayerSlide;
    image_speed = 1/2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set gravity direction

if abs(global.grav) == 2 {
    gravity_direction = 0
} else {
    gravity_direction = 270
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player actions and movement

//Left-right input
var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
var h = 0;
if (!frozen)
    { h = -(L || R) + (2 * R); }
if global.grav == 2 h = -h;
    
var ice = p_instance_place(0, sign(global.grav), objIceBlock);
var notOnBlock = p_place_free(0, sign(global.grav));
var onVineL = (p_place_meeting(-1, 0, objVineL) &amp;&amp; notOnBlock);
var onVineR = (p_place_meeting(1, 0, objVineR) &amp;&amp; notOnBlock);

//Horizontal movement
if (h != 0)    //Moving
{
    xScale = h;
    if (abs(global.grav) &gt; 1) {
        xScale = -xScale
    }
    if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
    {
        if (ice == noone)    //Normal movement
            { p_hspeed(runSpeed * h); }
        else    //Ice movement
        {
            p_hspeed_add((ice.slip) * h);
            
            if (abs(p_hspeed()) &gt; runSpeed)
                p_hspeed(runSpeed * h);
        }
    }
}
else    //Not moving
{
    if (ice == noone)    //Normal movement
        p_hspeed(0);
    else    //Ice movement
    {
        if (p_hspeed() &gt; 0)
            { p_hspeed_add(min(ice.slip, abs(p_hspeed()))); }
        else if (p_hspeed() &lt; 0)
            { p_hspeed_add(min(ice.slip, abs(p_hspeed()))); }
    }
}

onPlatform = false;
with(objPlatform)
{
    if abs(global.grav) == 1 {
        if (place_meeting(x, y-sign(global.grav), other))
        {
            if ((global.grav == 1 &amp;&amp; other.bbox_bottom &lt;= bbox_top &amp;&amp; p_vspeed() &gt;= vspeed) || (global.grav == -1 &amp;&amp; other.bbox_top &gt;= bbox_bottom &amp;&amp; p_vspeed() &lt;= vspeed))
            {
                other.onPlatform = true;
            }
        }
    } else {
        if place_meeting(x - sign(global.grav), y, other) {
            if (global.grav == 2 &amp;&amp; other.bbox_right &lt;= bbox_left &amp;&amp; p_vspeed() &gt;= hspeed) || (global.grav == -2 &amp;&amp; other.bbox_left &gt;= bbox_right &amp;&amp; p_vspeed() &lt;= hspeed) {
                other.onPlatform = true
            }
        }
    }
}

var conveyor = p_instance_place(0, sign(global.grav), objConveyor);
if (conveyor != noone)
{
    p_hspeed_add(conveyor.h);
}

if (abs(p_vspeed()) &gt; maxVspeed) {
    p_vspeed(sign(p_vspeed()) * maxVspeed);
}

if (!frozen)
{
    if (scrButtonCheckPressed(KEY.SHOOT))
        scrPlayerShoot();
    if (scrButtonCheckPressed(KEY.JUMP))
        scrPlayerJump();
    if (scrButtonCheckReleased(KEY.JUMP))
        scrPlayerReleaseJump();
    if (scrButtonCheckPressed(KEY.SUICIDE))
        scrKillPlayer();
}

if (global.adAlign &amp;&amp; !p_place_free(0, sign(global.grav)) &amp;&amp; !frozen)
{
    if (scrButtonCheckPressed(KEY.ALIGN_LEFT)) {p_hspeed_add(-1);}
    if (scrButtonCheckPressed(KEY.ALIGN_RIGHT)) {p_hspeed_add(1);}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Vines                                            

if (onVineL || onVineR)
{
    if (onVineR)
        { xScale = -1; }
    else
        { xScale = 1; }
    
    p_vspeed(2);
    
    //Try to leave vine
    if (onVineL &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)) || (onVineR &amp;&amp; scrButtonCheckPressed(KEY.LEFT))
    {
        if (scrButtonCheck(KEY.JUMP))    //Jumping off
        {
            if (onVineR)
                { p_hspeed(-15); }
            else
                { p_hspeed(15); }
            p_vspeed(-9);
            audio_play_sound(sndWallJump, 0, false);
        }
        else    // You fell off (+ratio)
        {
            if (onVineR)
                { p_hspeed(-3); }
            else
                { p_hspeed(3); }
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Slopes         

if (instance_exists(objSlope) &amp;&amp; hspeed != 0)
{
    var moveLimit = abs(hspeed);    //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
    
    var slopeCheck;
    var hTest;
    
    var ySlope;
    
    //falling onto a slope
    if (place_meeting(x+hspeed, y+vspeed+gravity, objSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
    {
        var xLast = x;
        var yLast = y;
        var hLast = hspeed;
        var vLast = vspeed;
        
        vspeed += gravity;
        
        x += hspeed;
        hspeed = 0;
        
        if(!place_free(x, y+vspeed))
        {
            if (global.grav == 1)    //Normal
                move_contact_solid(270, abs(vspeed));
            else    //Flipped
                move_contact_solid(90, abs(vspeed));
            vspeed = 0;
        }
        
        y += vspeed;            
        
        if (!place_free(x, y + global.grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
        {
            djump = 1;
            notOnBlock = false;
        }
        else    //Did not snap onto the slope, return to previous position
        {
            x = xLast;
            y = yLast;
            hspeed = hLast;
            vspeed = vLast;
        }
    }
    
    //Moving down a slope
    if (!notOnBlock)
    {                                              
        var onSlope = (place_meeting(x, y + global.grav, objSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
        
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            //Check how far we should move down
            while ((!place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav))) &amp;&amp; (ySlope*global.grav &gt; -floor(moveLimit * (hTest/hspeed))))
            {
                ySlope -= global.grav;
            }
            
            //Check if we actually need to move down
            if (place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav)))
            {
                if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                {
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
            else
            {
                slopeCheck = false;
            }
        }
    }
    
    //Moving up a slope
    if (place_meeting(x + hspeed, y, objSlope))
    {                                           
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            
            //Check how far we have to move up
            while ( place_meeting(x + hTest, y - ySlope, objSlope) &amp;&amp; (ySlope*global.grav &lt; floor(moveLimit * (hTest/hspeed))) )
            {
                ySlope += global.grav;
            }                                                 
            
            //Check if we actually need to move up
            if (place_free(x + hTest, y - ySlope))
            {            
                y -= ySlope;
                
                x += hTest;
                hspeed = 0;
                
                slopeCheck = false;
            }
            else
            {
                if (hTest &gt; 0)
                {
                    hTest -= 1;
                    if (hTest &lt;= 0)
                        slopeCheck = false;
                }
                else if (hTest &lt; 0)
                {
                    hTest += 1;
                    if (hTest &gt;= 0)
                        slopeCheck = false;
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
    }
    
    //Set xprevious/yprevious coordinates for future solid collisions
    xprevious = x;
    yprevious = y;
}                 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Block collision (Keep this last)

p_vspeed_add(gravity);

if (!p_place_free(p_hspeed(), p_vspeed()))
{
    // wallhugs
    if (!p_place_free(p_hspeed(), 0) &amp;&amp; p_hspeed() != 0)
    {
        var maxDist = abs(p_hspeed());
        var dir = 180 * (p_hspeed() &lt; 0);
        if abs(global.grav) &gt; 1  {
            var dir = 270;
            if p_hspeed() &lt; 0 dir = 90;
        }
        move_contact_solid(dir, maxDist);
        
        p_hspeed(0);
    }
    
    // gravity
    if (!p_place_free(0, p_vspeed()) &amp;&amp; p_vspeed() != 0)
    {
        var maxDist = abs(p_vspeed());
        var dir = 270 - 180 * (p_vspeed() &lt; 0);
        if abs(global.grav) &gt; 1  {
            var dir = 0;
            if p_vspeed() &lt; 0 dir = 180;
        }
        move_contact_solid(dir, maxDist);
        
        if abs(global.grav) &lt;= 1  {
            if (dir == 180 + sign(global.grav) * 90)
                { djump = 1; }
        } else {
            if (dir == 90 - (sign(global.grav) * 90))
                { djump = 1; }
        }
        
        p_vspeed(0);
    }
    
    if (!p_place_free(p_hspeed(), p_vspeed()))
        { p_hspeed(0); }
}

xsafe = x + p_hspeed();
ysafe = y + p_vspeed();

p_vspeed_add(-gravity);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Land on platforms, get snapped
//Being carried upwards is handled in objPlatform

switch global.grav {
    case 1: // Normal gravity
        var landedOnPlatform = bbox_bottom - vspeed - 1 &lt;= other.bbox_top - min(other.vspeed, 0);
        var jumpedOut = bbox_bottom + vspeed &lt;= other.bbox_top + other.vspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.y - (bbox_bottom - y) - 1;
            move_contact_solid(90, y - yy); //Move against solid to not get snapped into a wall
            vspeed = max(other.vspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
    case -1: // Upside down gravity
        var landedOnPlatform = bbox_top - vspeed + 1 &gt;= other.bbox_bottom - max(other.vspeed, 0);
        var jumpedOut = bbox_top + vspeed &gt;= other.bbox_bottom + other.vspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.y + other.sprite_height + (y - bbox_top);
            move_contact_solid(270, yy - y);
            vspeed = min(other.vspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
    case 2: // Right gravity
        var landedOnPlatform = bbox_right - hspeed - 1 &lt;= other.bbox_left - min(other.hspeed, 0);
        var jumpedOut = bbox_right + hspeed &lt;= other.bbox_left + other.hspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.x - (bbox_right - x) - 1;
            move_contact_solid(180, x - yy); //Move against solid to not get snapped into a wall
            hspeed = max(other.hspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
    case -2: // Left gravity
        var landedOnPlatform = bbox_left - hspeed + 1 &gt;= other.bbox_right - max(other.hspeed, 0);
        var jumpedOut = bbox_left + hspeed &gt;= other.bbox_right + other.hspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.x + other.sprite_width + (x - bbox_left);
            move_contact_solid(0, yy - x);
            hspeed = min(other.hspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Autosave

if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player

var drawX = floor(x + 0.5);
var drawY = floor(y + 0.5);
var drawAngle = image_angle + (90 * (abs(global.grav) &gt; 1));

if (global.grav == -1)      //Need to draw the player a pixel off in the y-axis when flipped for some reason
    { drawY += 1; }

draw_sprite_ext(sprite_index, image_index, drawX, drawY, image_xscale * xScale, image_yscale * sign(global.grav), drawAngle, image_blend, image_alpha);

//Draw the player's hitbox
if (global.debugShowHitbox)
    { draw_sprite_ext(mask_index, image_index, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha * 0.8); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
