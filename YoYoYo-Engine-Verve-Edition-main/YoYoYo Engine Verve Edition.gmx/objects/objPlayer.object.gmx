<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frozen = false; //Sets if the player can move or not

jumpSpeed = 8.5 * global.grav; //Set how fast the player jumps
djumpSpeed = 7 * global.grav; //Sets how fast the player double jumps
gravity = 0.4 * global.grav; //Player gravity

djump = 1; //Allow the player to double jump as soon as he spawns
runSpeed = 3;   //Max horizontal speed
maxVspeed = 9;  //Max vertical speed
image_speed = 0.2;
onPlatform = false;

xScale = 1;

scrSetPlayerMask();

if (global.difficulty == 0 &amp;&amp; global.gameStarted)
    { instance_create(x,y,objBow); }
    
if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}

xsafe = x;
ysafe = y;

scrDynamicCollision(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy the bow
with (objBow)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Resolve collisions between step and now, collide with dynamic blocks

if (!place_free(x, y))
{
    var dirX = sign(x-xsafe);
    var dirY = sign(y-ysafe);
    var epsilon = 0.001; //Appease the floating point gods
    
    //If something moved the player into a block since Step, move back towards where we were until we're out of a block.
    while(!place_free(x, y))
    {
        if (dirX * (x - xsafe) &gt;= epsilon)
        {
            x -= sign(x-xsafe) * min( abs(x-xsafe), 1 );
        }
        else if (dirY * (y - ysafe) &gt;= epsilon)
        {
            y -= sign(y-ysafe) * min( abs(y-ysafe), 1 );
        }
        else break;
    }
}

if (global.blocksCrush)
{
    scrDynamicCollision(false, scrKillPlayer);
}
else
{
    scrDynamicCollision(false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision

var killer = instance_place(x, y, objPlayerKiller)
if (killer != noone)
{
    scrKillPlayer();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Screen border death, player animation

if ((bbox_right &lt; 0 || bbox_left &gt; room_width || bbox_bottom &lt; 0 || bbox_top &gt; room_height) &amp;&amp; global.edgeDeath)
{
    scrKillPlayer();
}


var notOnBlock = (place_free(x, y + global.grav));
var onVineR = (place_meeting(x + 1, y, objVineR) &amp;&amp; notOnBlock);
var onVineL = (place_meeting(x - 1, y, objVineL) &amp;&amp; notOnBlock);

if (!onVineR &amp;&amp; !onVineL)   //Not touching any vines
{
    if (onPlatform || !notOnBlock)  //Standing on something
    {
        //Check if moving left/right
        var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
        var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
        
        if ((L || R) &amp;&amp; !frozen)
        {
            sprite_index = sprPlayerRun;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprPlayerIdle;
            image_speed = 1/5;
        }
    }
    else    //In the air
    { 
        if ((vspeed * global.grav) &lt; 0)
        {
            sprite_index = sprPlayerJump;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprPlayerFall;
            image_speed = 1/2;
        }
    }
}
else    //Touching a vine
{
    sprite_index = sprPlayerSlide;
    image_speed = 1/2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player actions and movement

//Left-right input
var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
var h = 0;
if (!frozen)
    { h = -(L || R) + (2 * R); }

var ice = instance_place(x, y + global.grav, objIceBlock);
var notOnBlock = place_free(x, y + global.grav);
var onVineL = (place_meeting(x - 1, y, objVineL) &amp;&amp; notOnBlock);
var onVineR = (place_meeting(x + 1, y, objVineR) &amp;&amp; notOnBlock);

//Horizontal movement
if (h != 0)    //Moving
{
    xScale = h;
    if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
    {
        if (ice == noone)    //Normal movement
            { hspeed = runSpeed * h; }
        else    //Ice movement
        {
            hspeed += (ice.slip) * h;
            
            if (abs(hspeed) &gt; runSpeed)
                hspeed = runSpeed * h;
        }
    }
}
else    //Not moving
{
    if (ice == noone)    //Normal movement
        hspeed = 0;
    else    //Ice movement
    {
        if (hspeed &gt; 0)
            { hspeed -= min(ice.slip, abs(hspeed)); }
        else if (hspeed &lt; 0)
            { hspeed += min(ice.slip, abs(hspeed)); }
    }
}

onPlatform = false;
with(objPlatform)
{
    if (place_meeting(x, y-global.grav, other))
    {
        if ((global.grav == 1 &amp;&amp; other.bbox_bottom &lt;= bbox_top &amp;&amp; other.vspeed &gt;= vspeed) || (global.grav == -1 &amp;&amp; other.bbox_top &gt;= bbox_bottom &amp;&amp; other.vspeed &lt;= vspeed))
        {
            other.onPlatform = true;
        }
    }
}

var conveyor = instance_place(x,y + (global.grav), objConveyor);
if (conveyor != noone)
{
    hspeed += conveyor.h;
}

if (global.grav * vspeed &gt; maxVspeed)
{
    vspeed = global.grav * maxVspeed;
}

if (!frozen)
{
    if (scrButtonCheckPressed(KEY.SHOOT))
        scrPlayerShoot();
    if (scrButtonCheckPressed(KEY.JUMP))
        scrPlayerJump();
    if (scrButtonCheckReleased(KEY.JUMP))
        scrPlayerReleaseJump();
    if (scrButtonCheckPressed(KEY.SUICIDE))
        scrKillPlayer();
}

if (global.adAlign &amp;&amp; !place_free(x, y + (global.grav)) &amp;&amp; !frozen)
{
    if (scrButtonCheckPressed(KEY.ALIGN_LEFT)) {hspeed -= 1;}
    if (scrButtonCheckPressed(KEY.ALIGN_RIGHT)) {hspeed += 1;}
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Vines                                            

if (onVineL || onVineR)
{
    if (onVineR)
        { xScale = -1; }
    else
        { xScale = 1; }
    
    vspeed = 2 * global.grav;
    
    //Try to leave vine
    if (onVineL &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)) || (onVineR &amp;&amp; scrButtonCheckPressed(KEY.LEFT))
    {
        if (scrButtonCheck(KEY.JUMP))    //Jumping off
        {
            if (onVineR)
                { hspeed = -15; }
            else
                { hspeed = 15; }
            vspeed = -9 * global.grav;
            audio_play_sound(sndWallJump, 0, false);
        }
        else    //Falling off
        {
            if (onVineR)
                { hspeed = -3; }
            else
                { hspeed = 3; }
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Slopes         

if (instance_exists(objSlope) &amp;&amp; hspeed != 0)
{
    var moveLimit = abs(hspeed);    //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
    
    var slopeCheck;
    var hTest;
    
    var ySlope;
    
    //falling onto a slope
    if (place_meeting(x+hspeed, y+vspeed+gravity, objSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
    {
        var xLast = x;
        var yLast = y;
        var hLast = hspeed;
        var vLast = vspeed;
        
        vspeed += gravity;
        
        x += hspeed;
        hspeed = 0;
        
        if(!place_free(x, y+vspeed))
        {
            if (global.grav == 1)    //Normal
                move_contact_solid(270, abs(vspeed));
            else    //Flipped
                move_contact_solid(90, abs(vspeed));
            vspeed = 0;
        }
        
        y += vspeed;            
        
        if (!place_free(x, y + global.grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
        {
            djump = 1;
            notOnBlock = false;
        }
        else    //Did not snap onto the slope, return to previous position
        {
            x = xLast;
            y = yLast;
            hspeed = hLast;
            vspeed = vLast;
        }
    }
    
    //Moving down a slope
    if (!notOnBlock)
    {                                              
        var onSlope = (place_meeting(x, y + global.grav, objSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
        
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            //Check how far we should move down
            while ((!place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav))) &amp;&amp; (ySlope*global.grav &gt; -floor(moveLimit * (hTest/hspeed))))
            {
                ySlope -= global.grav;
            }
            
            //Check if we actually need to move down
            if (place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav)))
            {
                if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                {
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
            else
            {
                slopeCheck = false;
            }
        }
    }
    
    //Moving up a slope
    if (place_meeting(x + hspeed, y, objSlope))
    {                                           
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            
            //Check how far we have to move up
            while ( place_meeting(x + hTest, y - ySlope, objSlope) &amp;&amp; (ySlope*global.grav &lt; floor(moveLimit * (hTest/hspeed))) )
            {
                ySlope += global.grav;
            }                                                 
            
            //Check if we actually need to move up
            if (place_free(x + hTest, y - ySlope))
            {            
                y -= ySlope;
                
                x += hTest;
                hspeed = 0;
                
                slopeCheck = false;
            }
            else
            {
                if (hTest &gt; 0)
                {
                    hTest -= 1;
                    if (hTest &lt;= 0)
                        slopeCheck = false;
                }
                else if (hTest &lt; 0)
                {
                    hTest += 1;
                    if (hTest &gt;= 0)
                        slopeCheck = false;
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
    }
    
    //Set xprevious/yprevious coordinates for future solid collisions
    xprevious = x;
    yprevious = y;
}                 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Block collision (Keep this last)

vspeed += gravity;

if (!place_free(x + hspeed, y + vspeed))
{
    if (!place_free(x + hspeed, y) &amp;&amp; hspeed != 0)
    {
        var maxDist = abs(hspeed);
        var dir = 180 * (hspeed &lt; 0);
        move_contact_solid(dir, maxDist);
        
        hspeed = 0;
    }
     
    if (!place_free(x, y + vspeed) &amp;&amp; vspeed != 0)
    {
        var maxDist = abs(vspeed);
        var dir = 270 - 180 * (vspeed &lt; 0);
        move_contact_solid(dir, maxDist);
        
        if (dir == 180 + global.grav * 90)
            { djump = 1; }
        vspeed = 0;
    }
    
    if (!place_free(x + hspeed, y + vspeed))
    {
        //hspeed = 0;
        //Traditional behavior when resolving corner collision is to stop hspeed. When on a platform, this can cause horizontal stutter, so we stop vspeed instead.
        var p = instance_place(x, y+vspeed, objPlatform);
        if (!p || place_meeting(x, y, p))
        {
            hspeed = 0;
        }
        else
        {
            vspeed = 0;
        }
    }
}

xsafe = x + hspeed;
ysafe = y + vspeed;

vspeed -= gravity;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Land on platforms, get snapped
//Being carried upwards is handled in objPlatform

if (global.grav == 1)    //Normal
{
    var landedOnPlatform = bbox_bottom - vspeed - 1 &lt;= other.bbox_top - min(other.vspeed, 0);
    var jumpedOut = bbox_bottom + vspeed &lt;= other.bbox_top + other.vspeed;
    
    if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
    {
        var yy = other.y - (bbox_bottom - y) - 1;
        if (!global.platformsPhase)
        {
            move_contact_solid(90, y - yy); //Move against solid to not get snapped into a wall
        }
        else
        {
            y = yy;
            ysafe = y;
        }
        vspeed = max(other.vspeed, 0);
        
        onPlatform = true;
        djump = 1;
    }
}
else    //Flipped
{
    var landedOnPlatform = bbox_top - vspeed + 1 &gt;= other.bbox_bottom - max(other.vspeed, 0);
    var jumpedOut = bbox_top + vspeed &gt;= other.bbox_bottom + other.vspeed;
    
    if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
    {
        var yy = other.y + other.sprite_height + (y - bbox_top);
        if (!global.platformsPhase)
        {
            move_contact_solid(270, yy - y);
        }
        else
        {
            y = yy;
            ysafe = y;
        }
        vspeed = min(other.vspeed, 0);
        
        onPlatform = true;
        djump = 1;
    }
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Autosave

if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player

var drawX = floor(x + 0.5);
var drawY = floor(y + 0.5);

if (global.grav == -1)      //Need to draw the player a pixel off in the y-axis when flipped for some reason
    { drawY += 1; }

draw_sprite_ext(sprite_index, image_index, drawX, drawY, image_xscale * xScale, image_yscale * global.grav, image_angle, image_blend, image_alpha);

//Draw the player's hitbox
if (global.debugShowHitbox)
    { draw_sprite_ext(mask_index, image_index, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha * 0.8); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
