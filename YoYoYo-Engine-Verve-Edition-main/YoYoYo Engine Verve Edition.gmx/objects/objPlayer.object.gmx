<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frozen = false; //Sets if the player can move or not

jumpSpeed = 8.5 * sign(global.grav); //Set how fast the player jumps
djumpSpeed = 7 * sign(global.grav); //Sets how fast the player double jumps
gravity = 0.4 * sign(global.grav); //Player gravity

djump = 1; //Allow the player to double jump as soon as he spawns
numJumps = 2 //2 for normal double jump, 1 for only single jumps, 3 for triple jump. See scrPlayerJump
runSpeed = 3;   //Max horizontal speed
maxVspeed = 9;  //Max vertical speed
image_speed = 0.2;
onPlatform = false;

xScale = 1;

scrSetPlayerMask();

if (global.difficulty == 0 &amp;&amp; global.gameStarted)
    { instance_create(x,y,objBow); }
    
if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}

//Control variables
highGrav = false
lowGrav = false
vineGrav = false
vineSpeed = false
vineStick = false
highSpeed = false
iframes = 0

xsafe = x;
ysafe = y;

scrDynamicCollision(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy the bow
with (objBow)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Resolve collisions between step and now, collide with dynamic blocks

if (!place_free(x, y))
{
    var dirX = sign(x-xsafe);
    var dirY = sign(y-ysafe);
    var epsilon = 0.001; //Appease the floating point gods
    
    //If something moved the player into a block since Step, move back towards where we were until we're out of a block.
    while(!place_free(x, y))
    {
        if (dirX * (x - xsafe) &gt;= epsilon)
        {
            x -= sign(x-xsafe) * min( abs(x-xsafe), 1 );
        }
        else if (dirY * (y - ysafe) &gt;= epsilon)
        {
            y -= sign(y-ysafe) * min( abs(y-ysafe), 1 );
        }
        else break;
    }
}

if (global.blocksCrush)
{
    scrDynamicCollision(false, scrKillPlayer);
}
else
{
    scrDynamicCollision(false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision

var killer = instance_place(x, y, objPlayerKiller)
if (killer != noone)
{
    scrKillPlayer();
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Screen border death, player animation

if ((bbox_right &lt; 0 || bbox_left &gt; room_width || bbox_bottom &lt; 0 || bbox_top &gt; room_height) &amp;&amp; global.edgeDeath)
{
    scrKillPlayer();
}

//Special player skins
var skin = SKIN.DEFAULT;
if global.dotkid {
    skin = SKIN.DOTKID;
}
else if global.playerV {
    skin = SKIN.VVV;
}
else if instance_exists(objYoshiControl) {
    skin = SKIN.YOSHI;
}
scrGetPlayerSkin(skin);

var notOnBlock = (p_place_free(0, sign(global.grav)));
var onVineR = (p_place_meeting(1, 0, objVineR) &amp;&amp; notOnBlock);
var onVineL = (p_place_meeting(-1, 0, objVineL) &amp;&amp; notOnBlock);
/*
var onVineR = scrVineCheck(x + 1, y, objVineR, notOnBlock);
var onVineL = scrVineCheck(x - 1, y, objVineL, notOnBlock);
//*/

if (!onVineR &amp;&amp; !onVineL)   //Not touching any vines
{
    if (onPlatform || !notOnBlock)  //Standing on something
    {
        //Check if moving left/right
        var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
        var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
        
        if ((L || R) &amp;&amp; !frozen)
        {
            sprite_index = sprRun;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprIdle;
            image_speed = 1/5;
        }
    }
    else    //In the air
    { 
        if ((vspeed * global.grav) &lt; 0)
        {
            sprite_index = sprJump;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprFall;
            image_speed = 1/2;
        }
    }
}
else if !global.dotkid //Touching a vine
{
    sprite_index = sprSlide;
    image_speed = 1/2;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set gravity direction

if abs(global.grav) == 2 {
    gravity_direction = 0
} else {
    gravity_direction = 270
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player actions and movement

//Gravity fields
gravity = 0.4*global.grav
if (place_meeting(x, y, objHighGravityField) || highGrav == true) {
    gravity = 0.7*global.grav
} else if (place_meeting(x, y, objLowGravityField) || lowGrav == true) {
    gravity = 0.2*global.grav
} else if (vineStick) {
    gravity = 0
    vineStick = false
} else if (vineGrav) {
    gravity = 0.3*global.grav
}

//Speed fields
if !vineSpeed &amp;&amp; !instance_exists(objYoshiControl) {
    runSpeed = 3
    if place_meeting(x, y, objLowSpeedField) {
        runSpeed = 1
    } else if (place_meeting(x, y, objHighSpeedField) || highSpeed = true) {
        runSpeed = 6
    }
}

//Magnet fields
if place_meeting(x, y, objMagnetField) {
    vspeed -= 0.71
    djump = 1
}

//Elevator blocks
if place_meeting(x, y, objElevatorBlockUp) {
    vspeed = -3 * global.grav
}
else if place_meeting(x, y, objElevatorBlockDown) {
    vspeed = 3 * global.grav
}


//Left-right input
if global.invertControls {
    var R = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
    var L = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
} else {
    var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
    var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
}
var h = 0;
if (!frozen)
    { h = -(L || R) + (2 * R); }
if global.grav == 2 h = -h;
    
var ice = p_instance_place(0, sign(global.grav), objIceBlock);
var notOnBlock = p_place_free(0, sign(global.grav));

var onVineL = (p_place_meeting(-1, 0, objVineL) &amp;&amp; notOnBlock);
var onVineR = (p_place_meeting(1, 0, objVineR) &amp;&amp; notOnBlock);
var vineL = noone; if onVineL { vineL = p_instance_place(-1, 0, objVineL); }
var vineR = noone; if onVineR { vineR = p_instance_place(1, 0, objVineR); }

if iframes &gt; 0 { iframes -= 1 }

/*
var onVineL = scrVineCheck(x - 1, y, objVineL, notOnBlock);
var onVineR = scrVineCheck(x + 1, y, objVineR, notOnBlock);
//*/

//Horizontal movement
if (h != 0)    //Moving
{
    xScale = h;
    if (abs(global.grav) &gt; 1) {
        xScale = -xScale
    }
    if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
    {
        if (ice == noone)    //Normal movement
            { p_hspeed(runSpeed * h); }
        else    //Ice movement
        {
            p_hspeed_add((ice.slip) * h);
            
            if (abs(p_hspeed()) &gt; runSpeed)
                p_hspeed(runSpeed * h);
        }
    }
}
else    //Not moving
{
    if (ice == noone)    //Normal movement
        p_hspeed(0);
    else    //Ice movement
    {
        if (p_hspeed() &gt; 0)
            { p_hspeed_add(min(ice.slip, abs(p_hspeed()))); }
        else if (p_hspeed() &lt; 0)
            { p_hspeed_add(min(ice.slip, abs(p_hspeed()))); }
    }
}

onPlatform = false;
with(objPlatform)
{
    if abs(global.grav) == 1 {
        if (place_meeting(x, y-sign(global.grav), other))
        {
            if ((global.grav == 1 &amp;&amp; other.bbox_bottom &lt;= bbox_top &amp;&amp; p_vspeed() &gt;= vspeed) || (global.grav == -1 &amp;&amp; other.bbox_top &gt;= bbox_bottom &amp;&amp; p_vspeed() &lt;= vspeed))
            {
                other.onPlatform = true;
            }
        }
    } else {
        if place_meeting(x - sign(global.grav), y, other) {
            if (global.grav == 2 &amp;&amp; other.bbox_right &lt;= bbox_left &amp;&amp; p_vspeed() &gt;= hspeed) || (global.grav == -2 &amp;&amp; other.bbox_left &gt;= bbox_right &amp;&amp; p_vspeed() &lt;= hspeed) {
                other.onPlatform = true
            }
        }
    }
}

var conveyor = p_instance_place(0, sign(global.grav), objConveyor);
if (conveyor != noone)
{
    p_hspeed_add(conveyor.h);
}

if (abs(p_vspeed()) &gt; maxVspeed) {
    p_vspeed(sign(p_vspeed()) * maxVspeed);
}

if (!frozen)
{
    if (scrButtonCheckPressed(KEY.SHOOT))
        scrPlayerShoot();
    if (scrButtonCheckPressed(KEY.JUMP))
        {
            if global.playerV { scrVPlayerJump() } else { scrPlayerJump() }
        }
    if (scrButtonCheckReleased(KEY.JUMP))
        scrPlayerReleaseJump();
    if (scrButtonCheckPressed(KEY.SUICIDE))
        scrKillPlayer();
}

if (global.adAlign &amp;&amp; !p_place_free(0, sign(global.grav)) &amp;&amp; !frozen)
{
    if (scrButtonCheckPressed(KEY.ALIGN_LEFT)) {p_hspeed_add(-1);}
    if (scrButtonCheckPressed(KEY.ALIGN_RIGHT)) {p_hspeed_add(1);}
}

//Wind fields
var wind = p_instance_place(0, 0, objWindField);
if wind != noone {
    p_hspeed_add(wind.hsp)
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Vines                                            

if (onVineL || onVineR) &amp;&amp; !instance_exists(objYoshiControl)
{
    //Jungle adventure vines
    var onRise = ((onVineR &amp;&amp; vineR.object_index == objRiseVineR) || (onVineL &amp;&amp; vineL.object_index == objRiseVineL)); 
    var onIce = ((onVineR &amp;&amp; vineR.object_index == objIceVineR) || (onVineL &amp;&amp; vineL.object_index == objIceVineL)); 
    var onFlip = ((onVineR &amp;&amp; vineR.object_index == objFlipVineR) || (onVineL &amp;&amp; vineL.object_index == objFlipVineL)); 
    var onSticky = ((onVineR &amp;&amp; vineR.object_index == objStickyVineR) || (onVineL &amp;&amp; vineL.object_index == objStickyVineL));
    var onLowGrav = ((onVineR &amp;&amp; vineR.object_index == objLowGravVineR) || (onVineL &amp;&amp; vineL.object_index == objLowGravVineL));
    var onWhite = ((onVineR &amp;&amp; vineR.object_index == objTwinWhiteVineR) || (onVineL &amp;&amp; vineL.object_index == objTwinWhiteVineL));
    var onBlack = ((onVineR &amp;&amp; vineR.object_index == objTwinBlackVineR) || (onVineL &amp;&amp; vineL.object_index == objTwinBlackVineL));
    var onSpeed = ((onVineR &amp;&amp; vineR.object_index == objSpeedVineR) || (onVineL &amp;&amp; vineL.object_index == objSpeedVineL));

    if (onVineR)
        { xScale = -1; }
    else
        { xScale = 1; }
    
    p_vspeed(2);
	
    if !onIce {
        if onRise { vspeed = -2 * global.grav } else if onSticky { vspeed = 0; vineStick = true } else { vspeed = 2 * global.grav }
    }
    
    //Try to leave vine
    if (onVineL &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)) || (onVineR &amp;&amp; scrButtonCheckPressed(KEY.LEFT))
    {
        if (scrButtonCheck(KEY.JUMP))    //Jumping off
        {
            if (onVineR)
                { p_hspeed(-15); }
            else
                { p_hspeed(15); }
            p_vspeed(-9);
                
            if onFlip { scrFlipGrav(false) }
            vspeed = -9 * global.grav;
            audio_play_sound(sndWallJump, 0, false);
            if (onWhite || onBlack) { global.vineToggle = !global.vineToggle }
        }
        else    // You fell off (+ratio)
        {
            if (onVineR)
                { p_hspeed(-3); }
            else
                { p_hspeed(3); }
        }
        if onLowGrav { vineGrav = true }
        if onSpeed { runSpeed = 6; vineSpeed = true }
    }
}

//Particles for low grav / fire vines
if vineGrav &amp;&amp; global.count mod 10 == 1 {
    part_particles_create(global.partSys,x,y,global.vinePart,2); 
}
if vineSpeed &amp;&amp; global.count mod 3 == 1 {
    instance_create(x,y,objFirePart);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Slopes
// ......splat

if abs(global.grav) &lt;= 1 { // Vertical gravity
    if (instance_exists(objSlope) &amp;&amp; hspeed != 0)
    {
        var moveLimit = abs(hspeed);    //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
        
        var slopeCheck;
        var hTest;
        
        var ySlope;
        
        //falling onto a slope
        if (place_meeting(x+hspeed, y+vspeed+gravity, objSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
        {
            var xLast = x;
            var yLast = y;
            var hLast = hspeed;
            var vLast = vspeed;
            
            vspeed += gravity;
            
            x += hspeed;
            hspeed = 0;
            
            if(!place_free(x, y+vspeed))
            {
                if (global.grav == 1)    //Normal
                    move_contact_solid(270, abs(vspeed));
                else    //Flipped
                    move_contact_solid(90, abs(vspeed));
                vspeed = 0;
            }
            
            y += vspeed;            
            
            if (!place_free(x, y + global.grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
            {
                djump = 1;
                notOnBlock = false;
            }
            else    //Did not snap onto the slope, return to previous position
            {
                x = xLast;
                y = yLast;
                hspeed = hLast;
                vspeed = vLast;
            }
        }
        
        //Moving down a slope
        if (!notOnBlock)
        {                                              
            var onSlope = (place_meeting(x, y + global.grav, objSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
            
            slopeCheck = true;
            hTest = hspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                //Check how far we should move down
                while ((!place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav))) &amp;&amp; (ySlope*global.grav &gt; -floor(moveLimit * (hTest/hspeed))))
                {
                    ySlope -= global.grav;
                }
                
                //Check if we actually need to move down
                if (place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav)))
                {
                    if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                    {
                        y -= ySlope;
                        
                        x += hTest;
                        hspeed = 0;
                        
                        slopeCheck = false;
                    }
                    else
                    {
                        if (hTest &gt; 0)
                        {
                            hTest -= 1;
                            if (hTest &lt;= 0)
                                slopeCheck = false;
                        }
                        else if (hTest &lt; 0)
                        {
                            hTest += 1;
                            if (hTest &gt;= 0)
                                slopeCheck = false;
                        }
                        else
                        {
                            slopeCheck = false;
                        }
                    }
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
        
        //Moving up a slope
        if (place_meeting(x + hspeed, y, objSlope))
        {                                           
            slopeCheck = true;
            hTest = hspeed;
            
            while (slopeCheck)
            {
                ySlope = 0;
                
                //Check how far we have to move up
                while ( place_meeting(x + hTest, y - ySlope, objSlope) &amp;&amp; (ySlope*global.grav &lt; floor(moveLimit * (hTest/hspeed))) )
                {
                    ySlope += global.grav;
                }                                                 
                
                //Check if we actually need to move up
                if (place_free(x + hTest, y - ySlope))
                {            
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
        }
        
        //Set xprevious/yprevious coordinates for future solid collisions
        xprevious = x;
        yprevious = y;
    }
} else { // Sideways gravity
    if (instance_exists(objSlope) &amp;&amp; vspeed != 0)
    {
        var moveLimit = abs(vspeed);    //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
        
        var slopeCheck;
        var vTest;
        
        var xSlope;
        
        //falling onto a slope
        if (place_meeting(x+hspeed+gravity, y+vspeed, objSlope) &amp;&amp; (hspeed+gravity)*sign(global.grav) &gt; 0 &amp;&amp; notOnBlock)
        {
            var xLast = x;
            var yLast = y;
            var hLast = vspeed;
            var vLast = hspeed;
            
            hspeed += gravity;
            
            y += vspeed;
            vspeed = 0;
            
            if(!place_free(x+hspeed, y+vspeed))
            {
                if (global.grav == 2)    //Normal
                    move_contact_solid(0, abs(hspeed));
                else    //Flipped
                    move_contact_solid(180, abs(hspeed));
                hspeed = 0;
            }
            
            x += hspeed;            
            
            if (!place_free(x + sign(global.grav), y) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
            {
                djump = 1;
                notOnBlock = false;
            }
            else    //Did not snap onto the slope, return to previous position
            {
                x = xLast;
                y = yLast;
                vspeed = hLast;
                hspeed = vLast;
            }
        }
        
        //Moving down a slope
        if (!notOnBlock)
        {                                              
            var onSlope = (place_meeting(x + sign(global.grav), y, objSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
            
            slopeCheck = true;
            vTest = vspeed;
            
            while (slopeCheck)
            {
                xSlope = 0;
                //Check how far we should move down
                while ((!place_meeting(x + sign(global.grav) - xSlope, y + vTest, objSlope) || (onSlope &amp;&amp; place_free(x - xSlope + sign(global.grav), y + vTest))) &amp;&amp; (xSlope*sign(global.grav) &gt; -floor(moveLimit * (vTest/vspeed))))
                {
                    xSlope -= sign(global.grav);
                }
                
                //Check if we actually need to move down
                if (place_meeting(x - xSlope + sign(global.grav), y + vTest, objSlope) || (onSlope &amp;&amp; place_free(x  - xSlope + sign(global.grav), y + hTest)))
                {
                    if (xSlope != 0 &amp;&amp; place_free(x - xSlope, y + vTest))
                    {
                        x -= xSlope;
                        
                        y += vTest;
                        vspeed = 0;
                        
                        slopeCheck = false;
                    }
                    else
                    {
                        if (vTest &gt; 0)
                        {
                            vTest -= 1;
                            if (vTest &lt;= 0)
                                slopeCheck = false;
                        }
                        else if (vTest &lt; 0)
                        {
                            vTest += 1;
                            if (vTest &gt;= 0)
                                slopeCheck = false;
                        }
                        else
                        {
                            slopeCheck = false;
                        }
                    }
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
        
        //Moving up a slope
        if (place_meeting(x, y + vspeed, objSlope))
        {                                           
            slopeCheck = true;
            vTest = vspeed;
            
            while (slopeCheck)
            {
                xSlope = 0;
                
                //Check how far we have to move up
                while ( place_meeting(x - xSlope, y + vTest, objSlope) &amp;&amp; (xSlope*sign(global.grav) &lt; floor(moveLimit * (vTest/vspeed))) )
                {
                    xSlope += sign(global.grav);
                }                                                 
                
                //Check if we actually need to move up
                if (place_free(x - xSlope, y + vTest))
                {            
                    x -= xSlope;
                    
                    y += vTest;
                    vspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (vTest &gt; 0)
                    {
                        vTest -= 1;
                        if (vTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (vTest &lt; 0)
                    {
                        vTest += 1;
                        if (vTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
        }
        
        //Set xprevious/yprevious coordinates for future solid collisions
        xprevious = x;
        yprevious = y;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Block collision (Keep this last)

p_vspeed_add(gravity);

if (!p_place_free(p_hspeed(), p_vspeed()))
{
    // wallhugs
    if (!p_place_free(p_hspeed(), 0) &amp;&amp; p_hspeed() != 0)
    //Block collision moves push blocks back, so let's undo that
    with objPushBlock {
        x = xMoved
        y = yMoved
    }

    if (!place_free(x + hspeed, y) &amp;&amp; hspeed != 0)
    {
        var maxDist = abs(p_hspeed());
        var dir = 180 * (p_hspeed() &lt; 0);
        if abs(global.grav) &gt; 1  {
            var dir = 270;
            if p_hspeed() &lt; 0 dir = 90;
        }
        move_contact_solid(dir, maxDist);
        
        p_hspeed(0);
    }
     
    if (!place_free(x, y + vspeed) &amp;&amp; vspeed != 0)
    {
        //Reset vine variables
        if (vspeed &gt; 0 &amp;&amp; global.grav == 1) || (vspeed &lt; 0 &amp;&amp; global.grav == -1) {
            vineGrav = false;
            if vineSpeed {
                runSpeed = 3;
                vineSpeed = false;
            }
        }
    
        var maxDist = abs(vspeed);
        var dir = 270 - 180 * (vspeed &lt; 0);
        move_contact_solid(dir, maxDist);
        
        if (dir == 180 + global.grav * 90)
            { djump = 1; }
        vspeed = 0;
    }
    
    // gravity
    if (!p_place_free(0, p_vspeed()) &amp;&amp; p_vspeed() != 0)
    {
        var maxDist = abs(p_vspeed());
        var dir = 270 - 180 * (p_vspeed() &lt; 0);
        if abs(global.grav) &gt; 1  {
            var dir = 0;
            if p_vspeed() &lt; 0 dir = 180;
        }
        move_contact_solid(dir, maxDist);
        
        if abs(global.grav) &lt;= 1  {
            if (dir == 180 + sign(global.grav) * 90)
                { djump = 1; }
        } else {
            if (dir == 90 - (sign(global.grav) * 90))
                { djump = 1; }
        }
        
        p_vspeed(0);
    }
    
    if (!p_place_free(p_hspeed(), p_vspeed()))
        { p_hspeed(0); }
}

xsafe = x + p_hspeed();
ysafe = y + p_vspeed();

p_vspeed_add(-gravity);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Land on platforms, get snapped
//Being carried upwards is handled in objPlatform

switch global.grav {
    case 1: // Normal gravity
        var landedOnPlatform = bbox_bottom - vspeed - 1 &lt;= other.bbox_top - min(other.vspeed, 0);
        var jumpedOut = bbox_bottom + vspeed &lt;= other.bbox_top + other.vspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.y - (bbox_bottom - y) - 1;
            move_contact_solid(90, y - yy); //Move against solid to not get snapped into a wall
            vspeed = max(other.vspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
    case -1: // Upside down gravity
        var landedOnPlatform = bbox_top - vspeed + 1 &gt;= other.bbox_bottom - max(other.vspeed, 0);
        var jumpedOut = bbox_top + vspeed &gt;= other.bbox_bottom + other.vspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.y + other.sprite_height + (y - bbox_top);
            move_contact_solid(270, yy - y);
            vspeed = min(other.vspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
    case 2: // Right gravity
        var landedOnPlatform = bbox_right - hspeed - 1 &lt;= other.bbox_left - min(other.hspeed, 0);
        var jumpedOut = bbox_right + hspeed &lt;= other.bbox_left + other.hspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.x - (bbox_right - x) - 1;
            move_contact_solid(180, x - yy); //Move against solid to not get snapped into a wall
            hspeed = max(other.hspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
    case -2: // Left gravity
        var landedOnPlatform = bbox_left - hspeed + 1 &gt;= other.bbox_right - max(other.hspeed, 0);
        var jumpedOut = bbox_left + hspeed &gt;= other.bbox_right + other.hspeed;
        
        if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
        {
            var yy = other.x + other.sprite_width + (x - bbox_left);
            move_contact_solid(0, yy - x);
            hspeed = min(other.hspeed, 0);
            
            onPlatform = true;
            djump = 1;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Autosave

if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player

var drawX = floor(x + 0.5);
var drawY = floor(y + 0.5);
var drawAngle = image_angle + (90 * (abs(global.grav) &gt; 1));

if (global.grav == -1 &amp;&amp; !global.dotkid)      //Need to draw the player a pixel off in the y-axis when flipped for some reason
    { drawY += 1; }

if global.dotkid {
    if global.playerV {
        draw_sprite_ext(sprDotkidOutlinedV,0,drawX,drawY,image_xscale,image_yscale*global.grav,image_angle,image_blend,image_alpha);
    } else {
        draw_sprite_ext(sprDotkidOutlined,0,drawX,drawY,image_xscale,image_yscale*global.grav,image_angle,image_blend,image_alpha);
    }
} else {
    draw_sprite_ext(sprite_index, image_index, drawX, drawY, image_xscale * xScale, image_yscale * sign(global.grav), drawAngle, image_blend, image_alpha);
}

//Draw the player's hitbox
if (global.debugShowHitbox)
    { draw_sprite_ext(mask_index, image_index, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha * 0.8); }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
