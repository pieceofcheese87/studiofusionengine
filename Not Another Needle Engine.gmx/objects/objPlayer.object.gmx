<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>sprPlayerMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>frozen = false; //Sets if the player can move or not

jumpSpeed = 8.5 * global.grav; //Set how fast the player jumps
djumpSpeed = 7 * global.grav; //Sets how fast the player double jumps
gravity = 0.4 * global.grav; //Player gravity

djump = 1; //Allow the player to double jump as soon as he spawns
numJumps = 2 //2 for normal double jump, 1 for only single jumps, 3 for triple jump. See scrPlayerJump
runSpeed = 3;   //Max horizontal speed
maxVspeed = 9;  //Max vertical speed
image_speed = 0.2;
onPlatform = false;
onLadder = false;

xScale = 1;

scrSetPlayerMask();

if (global.difficulty == 0 &amp;&amp; global.gameStarted)
    { instance_create(x,y,objBow); }

//god mode variables
bow = false;
hit = 0;
hitX = x;
hitY = y;
        
if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}

//Control variables
highGrav = false
lowGrav = false
vineGrav = false
vineSpeed = false
vineStick = false
highSpeed = false
iframes = 0

xsafe = x;
ysafe = y;

scrDynamicCollision(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy the bow
with (objBow)
    instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Resolve collisions between step and now, collide with dynamic blocks

if (!place_free(x, y))
{
    var dirX = sign(x-xsafe);
    var dirY = sign(y-ysafe);
    var epsilon = 0.001; //Appease the floating point gods
    
    //If something moved the player into a block since Step, move back towards where we were until we're out of a block.
    while(!place_free(x, y))
    {
        if (dirX * (x - xsafe) &gt;= epsilon)
        {
            x -= sign(x-xsafe) * min( abs(x-xsafe), 1 );
        }
        else if (dirY * (y - ysafe) &gt;= epsilon)
        {
            y -= sign(y-ysafe) * min( abs(y-ysafe), 1 );
        }
        else break;
    }
}

if (global.blocksCrush)
{
    scrDynamicCollision(false, scrKillPlayer);
}
else
{
    scrDynamicCollision(false);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Killer collision

var killer = instance_place(x, y, objPlayerKiller)
if (killer != noone)
{
    scrKillPlayer();
}

//Control how long the player is intangible after being hit while god mode is active
if (hit != 0) 
{ 
    image_alpha = 0.7;
    hit -= 1; 
}
else { image_alpha = 1; }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Screen border death, player animation

if ((bbox_right &lt; 0 || bbox_left &gt; room_width || bbox_bottom &lt; 0 || bbox_top &gt; room_height) &amp;&amp; global.edgeDeath)
{
    scrKillPlayer();
}

//Special player skins
var skin = SKIN.DEFAULT;
if global.dotkid {
    skin = SKIN.DOTKID;
}
else if global.playerV || global.telekid {
    skin = SKIN.VVV;
}
else if instance_exists(objYoshiControl) {
    skin = SKIN.YOSHI;
}
scrGetPlayerSkin(skin);

var notOnBlock = (place_free(x, y + global.grav));
var onVineR = scrVineCheck(x + 1, y, objVineR, notOnBlock);
var onVineL = scrVineCheck(x - 1, y, objVineL, notOnBlock);

if (!onVineR &amp;&amp; !onVineL)   //Not touching any vines
{
    if (onPlatform || !notOnBlock)  //Standing on something
    {
        //Check if moving left/right
        var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
        var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
        
        if ((L || R) &amp;&amp; !frozen)
        {
            sprite_index = sprRun;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprIdle;
            image_speed = 1/5;
        }
    }
    else if onLadder {
        sprite_index = sprClimb;
        if(vspeed !=0 || hspeed !=0) image_speed = 1/5 else image_speed=0
    }
    else    //In the air
    { 
        if ((vspeed * global.grav) &lt; 0)
        {
            sprite_index = sprJump;
            image_speed = 1/2;
        }
        else
        {
            sprite_index = sprFall;
            image_speed = 1/2;
        }
    }
}
else if !global.dotkid //Touching a vine
{
    sprite_index = sprSlide;
    image_speed = 1/2;
}

if (global.debugNoDeath)
{
    if (!instance_exists(objBow))
    {
        godBow = instance_create(x, y, objBow);
        godBow.neg = true;
    }
    else 
    {
        if (global.difficulty == 0)
            with (objBow) { neg = true; }
    }
}
else 
{
    if (instance_exists(objBow)) 
    {
        with (objBow) {  
            if (global.difficulty == 0) { neg = false; }
            else { instance_destroy(); }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player actions and movement

//Stop climbing ladder if no longer touching one
var ladder = instance_place(x,y,objLadder);
if ladder == noone {
    onLadder = false
}

//Gravity fields
gravity = 0.4*global.grav
if (place_meeting(x, y, objHighGravityField) || highGrav == true) {
    gravity = 0.7*global.grav
} else if (place_meeting(x, y, objLowGravityField) || lowGrav == true) {
    gravity = 0.2*global.grav
} else if (place_meeting(x, y, objZeroGravityField)) {
    gravity = 0;
} else if (place_meeting(x, y, objAntiGravityField)) {
    gravity = -0.4*global.grav
} else if (vineStick) {
    gravity = 0
    vineStick = false
} else if (vineGrav) {
    gravity = 0.3*global.grav
}

//Speed fields
if !vineSpeed &amp;&amp; !instance_exists(objYoshiControl) {
    runSpeed = 3
    if place_meeting(x, y, objLowSpeedField) {
        runSpeed = 1
    } else if (place_meeting(x, y, objHighSpeedField) || highSpeed = true) {
        runSpeed = 6
    }
}

//Magnet fields
if place_meeting(x, y, objMagnetField) &amp;&amp; !onLadder {
    vspeed -= 0.71
    djump = 1
}

//Elevator blocks
if place_meeting(x, y, objElevatorBlockUp) &amp;&amp; !onLadder {
    vspeed = -3 * global.grav
}
else if place_meeting(x, y, objElevatorBlockDown) &amp;&amp; !onLadder {
    vspeed = 3 * global.grav
}


//Input
if global.invertControls {
    var R = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
    var L = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
    var U = onLadder &amp;&amp; (scrButtonCheck(KEY.DOWN) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.DOWN)));
    var D = onLadder &amp;&amp; (scrButtonCheck(KEY.UP) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.UP)));
} else {
    var L = (scrButtonCheck(KEY.LEFT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.LEFT)));
    var R = (scrButtonCheck(KEY.RIGHT) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)));
    var D = onLadder &amp;&amp; (scrButtonCheck(KEY.DOWN) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.DOWN)));
    var U = onLadder &amp;&amp; (scrButtonCheck(KEY.UP) || (global.directionalTapFix &amp;&amp; scrButtonCheckPressed(KEY.UP)));
}
var h = 0;
var v = 0;
if (!frozen)
    { h = -(L || R) + (2 * R); v = -(U || D) + (2 * D); }

var ice = instance_place(x, y + global.grav, objIceBlock);

if iframes &gt; 0 { iframes -= 1 }

var notOnBlock = (place_free(x, y + global.grav));
var onVineL = scrVineCheck(x - 1, y, objVineL, notOnBlock) &amp;&amp; !onLadder;
var onVineR = scrVineCheck(x + 1, y, objVineR, notOnBlock) &amp;&amp; !onLadder;
var vineL = noone; if onVineL { vineL = instance_place(x - 1, y, objVineL); }
var vineR = noone; if onVineR { vineR = instance_place(x + 1, y, objVineR); }

//Horizontal movement
if (h != 0)    //Moving
{
    xScale = h;
    if ((h == -1 &amp;&amp; !onVineR) || (h == 1 &amp;&amp; !onVineL))
    {
        if (ice == noone)    //Normal movement
            { hspeed = runSpeed * h; }
        else    //Ice movement
        {
            hspeed += (ice.slip) * h;
            
            if (abs(hspeed) &gt; runSpeed)
                hspeed = runSpeed * h;
        }
    }
}
else    //Not moving
{
    if (ice == noone)    //Normal movement
        hspeed = 0;
    else    //Ice movement
    {
        if (hspeed &gt; 0)
            { hspeed -= min(ice.slip, abs(hspeed)); }
        else if (hspeed &lt; 0)
            { hspeed += min(ice.slip, abs(hspeed)); }
    }
}

// Vertical movement on ladder
if (v != 0)
{
    vspeed = runSpeed * v
}
else if onLadder //Not moving
{
    vspeed = 0
}

onPlatform = false;
with(objPlatform)
{
    if (place_meeting(x, y-global.grav, other))
    {
        if ((global.grav == 1 &amp;&amp; other.bbox_bottom &lt;= bbox_top &amp;&amp; other.vspeed &gt;= vspeed) || (global.grav == -1 &amp;&amp; other.bbox_top &gt;= bbox_bottom &amp;&amp; other.vspeed &lt;= vspeed))
        {
            other.onPlatform = true;
            other.onLadder = false;
        }
    }
}

var conveyor = instance_place(x,y + (global.grav), objConveyor);
if (conveyor != noone &amp;&amp; !onLadder)
{
    hspeed += conveyor.h;
}

if (global.grav * vspeed &gt; maxVspeed)
{
    vspeed = global.grav * maxVspeed;
}

if (!frozen)
{
    if (scrButtonCheckPressed(KEY.SHOOT))
        scrPlayerShoot();
    if (scrButtonCheckPressed(KEY.JUMP))
        {
            if global.playerV { scrVPlayerJump() } else { scrPlayerJump() }
        }
    if (scrButtonCheckReleased(KEY.JUMP))
        scrPlayerReleaseJump();
    if (scrButtonCheckPressed(KEY.SUICIDE))
        scrKillPlayer();
}

if (global.adAlign &amp;&amp; !place_free(x, y + (global.grav)) &amp;&amp; !frozen)
{
    if (scrButtonCheckPressed(KEY.ALIGN_LEFT)) {hspeed -= 1;}
    if (scrButtonCheckPressed(KEY.ALIGN_RIGHT)) {hspeed += 1;}
}

//Wind fields
var wind = instance_place(x, y, objWindField);
if wind != noone &amp;&amp; !onLadder {
    hspeed += wind.hsp
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Vines                                            

if (onVineL || onVineR) &amp;&amp; !instance_exists(objYoshiControl)
{
    //Jungle adventure vines
    var onRise = ((onVineR &amp;&amp; vineR.object_index == objRiseVineR) || (onVineL &amp;&amp; vineL.object_index == objRiseVineL)); 
    var onIce = ((onVineR &amp;&amp; vineR.object_index == objIceVineR) || (onVineL &amp;&amp; vineL.object_index == objIceVineL)); 
    var onFlip = ((onVineR &amp;&amp; vineR.object_index == objFlipVineR) || (onVineL &amp;&amp; vineL.object_index == objFlipVineL)); 
    var onSticky = ((onVineR &amp;&amp; vineR.object_index == objStickyVineR) || (onVineL &amp;&amp; vineL.object_index == objStickyVineL));
    var onLowGrav = ((onVineR &amp;&amp; vineR.object_index == objLowGravVineR) || (onVineL &amp;&amp; vineL.object_index == objLowGravVineL));
    var onWhite = ((onVineR &amp;&amp; vineR.object_index == objTwinWhiteVineR) || (onVineL &amp;&amp; vineL.object_index == objTwinWhiteVineL));
    var onBlack = ((onVineR &amp;&amp; vineR.object_index == objTwinBlackVineR) || (onVineL &amp;&amp; vineL.object_index == objTwinBlackVineL));
    var onSpeed = ((onVineR &amp;&amp; vineR.object_index == objSpeedVineR) || (onVineL &amp;&amp; vineL.object_index == objSpeedVineL));

    if (onVineR)
        { xScale = -1; }
    else
        { xScale = 1; }
    
    if !onIce {
        if onRise { vspeed = -2 * global.grav } else if onSticky { vspeed = 0; vineStick = true } else { vspeed = 2 * global.grav }
    }
    
    //Try to leave vine
    if (onVineL &amp;&amp; scrButtonCheckPressed(KEY.RIGHT)) || (onVineR &amp;&amp; scrButtonCheckPressed(KEY.LEFT))
    {
        if (scrButtonCheck(KEY.JUMP))    //Jumping off
        {
            if (onVineR)
                { hspeed = -15; }
            else
                { hspeed = 15; }
                
            if onFlip { scrFlipGrav(false) }
            vspeed = -9 * global.grav;
            audio_play_sound(sndWallJump, 0, false);
            if (onWhite || onBlack) { global.vineToggle = !global.vineToggle }
        }
        else    //Falling off
        {
            if (onVineR)
                { hspeed = -3; }
            else
                { hspeed = 3; }
        }
        if onLowGrav { vineGrav = true }
        if onSpeed { runSpeed = 6; vineSpeed = true }
    }
}

//Particles for low grav / fire vines
if vineGrav &amp;&amp; global.count mod 10 == 1 {
    part_particles_create(global.partSys,x,y,global.vinePart,2); 
}
if vineSpeed &amp;&amp; global.count mod 3 == 1 {
    instance_create(x,y,objFirePart);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Slopes         

if (instance_exists(objSlope) &amp;&amp; hspeed != 0)
{
    var moveLimit = abs(hspeed);    //Sets how high/low the player can go to snap onto a slope, this can be increased to make the player able to run over steeper slopes (ie setting it to abs(hspeed)*2 allows the player to run over slopes twice as steep)
    
    var slopeCheck;
    var hTest;
    
    var ySlope;
    
    //falling onto a slope
    if (place_meeting(x+hspeed, y+vspeed+gravity, objSlope) &amp;&amp; (vspeed+gravity)*global.grav &gt; 0 &amp;&amp; notOnBlock)
    {
        var xLast = x;
        var yLast = y;
        var hLast = hspeed;
        var vLast = vspeed;
        
        vspeed += gravity;
        
        x += hspeed;
        hspeed = 0;
        
        if(!place_free(x, y+vspeed))
        {
            if (global.grav == 1)    //Normal
                move_contact_solid(270, abs(vspeed));
            else    //Flipped
                move_contact_solid(90, abs(vspeed));
            vspeed = 0;
        }
        
        y += vspeed;            
        
        if (!place_free(x, y + global.grav) &amp;&amp; place_free(x, y))  //Snapped onto the slope properly
        {
            djump = 1;
            notOnBlock = false;
        }
        else    //Did not snap onto the slope, return to previous position
        {
            x = xLast;
            y = yLast;
            hspeed = hLast;
            vspeed = vLast;
        }
    }
    
    //Moving down a slope
    if (!notOnBlock)
    {                                              
        var onSlope = (place_meeting(x, y + global.grav, objSlope));    //Treat normal blocks the same as slopes if we're standing on a slope
        
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            //Check how far we should move down
            while ((!place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav))) &amp;&amp; (ySlope*global.grav &gt; -floor(moveLimit * (hTest/hspeed))))
            {
                ySlope -= global.grav;
            }
            
            //Check if we actually need to move down
            if (place_meeting(x + hTest, y - ySlope + global.grav, objSlope) || (onSlope &amp;&amp; place_free(x + hTest, y - ySlope + global.grav)))
            {
                if (ySlope != 0 &amp;&amp; place_free(x + hTest, y - ySlope))
                {
                    y -= ySlope;
                    
                    x += hTest;
                    hspeed = 0;
                    
                    slopeCheck = false;
                }
                else
                {
                    if (hTest &gt; 0)
                    {
                        hTest -= 1;
                        if (hTest &lt;= 0)
                            slopeCheck = false;
                    }
                    else if (hTest &lt; 0)
                    {
                        hTest += 1;
                        if (hTest &gt;= 0)
                            slopeCheck = false;
                    }
                    else
                    {
                        slopeCheck = false;
                    }
                }
            }
            else
            {
                slopeCheck = false;
            }
        }
    }
    
    //Moving up a slope
    if (place_meeting(x + hspeed, y, objSlope))
    {                                           
        slopeCheck = true;
        hTest = hspeed;
        
        while (slopeCheck)
        {
            ySlope = 0;
            
            //Check how far we have to move up
            while ( place_meeting(x + hTest, y - ySlope, objSlope) &amp;&amp; (ySlope*global.grav &lt; floor(moveLimit * (hTest/hspeed))) )
            {
                ySlope += global.grav;
            }                                                 
            
            //Check if we actually need to move up
            if (place_free(x + hTest, y - ySlope))
            {            
                y -= ySlope;
                
                x += hTest;
                hspeed = 0;
                
                slopeCheck = false;
            }
            else
            {
                if (hTest &gt; 0)
                {
                    hTest -= 1;
                    if (hTest &lt;= 0)
                        slopeCheck = false;
                }
                else if (hTest &lt; 0)
                {
                    hTest += 1;
                    if (hTest &gt;= 0)
                        slopeCheck = false;
                }
                else
                {
                    slopeCheck = false;
                }
            }
        }
    }
    
    //Set xprevious/yprevious coordinates for future solid collisions
    xprevious = x;
    yprevious = y;
}                 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Block collision (Keep this last)

if !onLadder {
    vspeed += gravity;
}

if (!place_free(x + hspeed, y + vspeed))
{
    //Block collision moves push blocks back, so let's undo that
    with objPushBlock {
        x = xMoved
        y = yMoved
    }

    if (!place_free(x + hspeed, y) &amp;&amp; hspeed != 0)
    {
        var maxDist = abs(hspeed);
        var dir = 180 * (hspeed &lt; 0);
        move_contact_solid(dir, maxDist);
        
        hspeed = 0;
    }
     
    if (!place_free(x, y + vspeed) &amp;&amp; vspeed != 0)
    {
        //Reset vine variables
        if (vspeed &gt; 0 &amp;&amp; global.grav == 1) || (vspeed &lt; 0 &amp;&amp; global.grav == -1) {
            vineGrav = false;
            if vineSpeed {
                runSpeed = 3;
                vineSpeed = false;
            }
        }
    
        var maxDist = abs(vspeed);
        var dir = 270 - 180 * (vspeed &lt; 0);
        move_contact_solid(dir, maxDist);
        
        if (dir == 180 + global.grav * 90)
            { djump = 1; }
        vspeed = 0;
    }
    
    if (!place_free(x + hspeed, y + vspeed))
    {
        //hspeed = 0;
        //Traditional behavior when resolving corner collision is to stop hspeed. When on a platform, this can cause horizontal stutter, so we stop vspeed instead.
        var p = instance_place(x, y+vspeed, objPlatform);
        if (!p || place_meeting(x, y, p))
        {
            hspeed = 0;
        }
        else
        {
            vspeed = 0;
        }
    }
}

xsafe = x + hspeed;
ysafe = y + vspeed;

vspeed -= gravity;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="objPlatform">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Land on platforms, get snapped
//Being carried upwards is handled in objPlatform

if (global.grav == 1)    //Normal
{
    var landedOnPlatform = bbox_bottom - vspeed - 1 &lt;= other.bbox_top - min(other.vspeed, 0);
    var jumpedOut = bbox_bottom + vspeed &lt;= other.bbox_top + other.vspeed;
    
    if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
    {
        var yy = other.y - (bbox_bottom - y) - 1;
        if (!global.platformsPhase)
        {
            move_contact_solid(90, y - yy); //Move against solid to not get snapped into a wall
        }
        else
        {
            y = yy;
            ysafe = y;
        }
        vspeed = max(other.vspeed, 0);
        
        onPlatform = true;
        djump = 1;
    }
}
else    //Flipped
{
    var landedOnPlatform = bbox_top - vspeed + 1 &gt;= other.bbox_bottom - max(other.vspeed, 0);
    var jumpedOut = bbox_top + vspeed &gt;= other.bbox_bottom + other.vspeed;
    
    if (landedOnPlatform || (jumpedOut &amp;&amp; other.snap))
    {
        var yy = other.y + other.sprite_height + (y - bbox_top);
        if (!global.platformsPhase)
        {
            move_contact_solid(270, yy - y);
        }
        else
        {
            y = yy;
            ysafe = y;
        }
        vspeed = min(other.vspeed, 0);
        
        onPlatform = true;
        djump = 1;
    }
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Autosave

if (global.autosave) //Save the game if currently set to autosave
{
    scrSaveGame(true);
    global.autosave = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the player

var drawX = floor(x + 0.5);
var drawY = floor(y + 0.5);
var drawColor = c_white;

if global.playerV {
    drawColor = make_color_rgb(1,164,217) // blue color from original V kid sprite
} else if global.debugInfJump {
    drawColor = c_blue; 
} 

if (global.grav == -1 &amp;&amp; !global.dotkid)      //Need to draw the player a pixel off in the y-axis when flipped for some reason
    drawY += 1; 
    
// draw keypick master glow 
if instance_exists(objKeypickControl) &amp;&amp; objKeypickControl.usingMaster {
    draw_set_blend_mode(bm_add)
    draw_sprite(sprMasterGlow,0,drawX,drawY)
    draw_set_blend_mode(bm_normal)
    draw_set_alpha(0.6)
    draw_sprite(sprMasterKey,0,drawX-16,drawY-16)
    draw_set_alpha(1)
}
 
// draw dotkid   
if global.dotkid {
    var spr = scrTernary(global.playerV, sprDotkidOutlinedV, sprDotkidOutlined);
    draw_sprite_ext(spr, 0, drawX, drawY, image_xscale, image_yscale * global.grav, image_angle, drawColor, image_alpha);
} else {
    draw_sprite_ext(sprite_index, image_index, drawX, drawY, image_xscale * xScale, image_yscale * global.grav, image_angle, drawColor, image_alpha);
}

//Draw the player's hitbox
if (global.debugShowHitbox)
    draw_sprite_ext(mask_index, image_index, x, y, image_xscale, image_yscale, image_angle, image_blend, image_alpha * 0.8);
    
//Draw the player getting hit if god mode is active
if (hit != 0)
    draw_sprite_ext(sprPlayerHit, 0, hitX, hitY, 1, 1, 0, c_white, hit/floor(global.debugDeathSpeed/2));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
